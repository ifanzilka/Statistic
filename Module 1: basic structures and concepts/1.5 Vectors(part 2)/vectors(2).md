
## [Back](https://github.com/ifanzilka/Statistic_for_R/blob/main/Module%201:%20basic%20structures%20and%20concepts/readme.md)

# Оглавление
* [Fizz - buzz]()
* [Прогрессия ]()
* [Рандом]()
* [Задача 1]()
* [Задача 2]()

## Fizz - buzz

    # fizz-buzz, imperative style
    y <- vector(mode = "character", length = 100)
    y <- character(100)
    for (i in 1:100) {
      if (i %% 15 == 0) {
        y[i] <- "fizz buzz"
      } else if (i %% 3 == 0) {
        y[i] <- "fizz"
      } else if (i %% 5 == 0) {
        y[i] <- "buzz"
      } else {
        y[i] <- i
      }
    }
    y
2 Способ :
    
    # fizz-buzz, vector-oriented style
    x <- 1:100
    z <- 1:100
    x %% 5
    x %% 5 == 0
    z[x %% 5 == 0]
    z[x %% 5 == 0] <- "buzz"
    z[x %% 3 == 0] <- "fizz"
    z[x %% 15 == 0] <- "fizz buzz"
    z
    all(y == z)
## Прогрессия 

    # Geometric progression
    x <- 2 ^ (0:10)
    x
    log2(x)
    
## Рандом   
Выбираем 50 чисел из вектора (1:100)

    # Some randomness
    set.seed(42)
    x <- sample(1:100, 50)
Теперь найдем два соседних числа, отличающихся на макс. велечину
    
    # Neigbors with greatest diff
    x[-1]
    x[-length(x)]
    x[-1] - x[-length(x)]
    k <- which.max(abs(x[-1] - x[-length(x)]))
    x[c(k, k + 1)]
    
 Выборка с повторением :
 
    # Multiple min/max
    x <- sample(1:100, 50, replace = TRUE)
    min(x)
    which.min(x)
    which(x == min(x))

## Задача 1
Пусть вектор называется нестрого возрастающим, если каждый следующий элемент в нём не меньше, чем предыдущий. Точно так же, вектор назовём нестрого убывающим, если каждый следующий элемент в нём не больше, чем предыдущий. Напишите функцию, которая принимает один аргумент (числовой вектор) и возвращает TRUE, если вектор обладает свойством нестрогой монотонности, то есть является либо несторого возрастающим, либо нестрого убывающим. В противном случае функция возвращает FALSE.

Пример. x=c(0, 0, 3, 4, 4, 8) нестрого возрастает, возвращаем TRUE. y=c(3:0, 1) был бы нестрого убывающим, если бы не последняя единица, поэтому возвращаем FALSE.

Подсказки: 

"Не меньше" = "больше либо равно".
обратите внимание на постоянный вектор, например rep(0, 10). Является ли он нестрого возрастающим? А нестрого убывающим?

Решение :

    is_monotone <- function(x) {
        return(all(x[-length(x)]-x[-1] >=0) | all(x[-length(x)]-x[-1] <=0))
    }
# 
    is_monotone <- function(x) {
        all(diff(x) >= 0) || all(diff(x) <= 0)
    }
    
## Задача 2
Разбавим курс ложечкой комбинаторики. Пусть у нас есть n предметов, из которых нужно выбрать k штук.

Известнейшая комбинаторная формула C_n^k = \frac{n!}{k!(n-k)!}C 
n
k
​	
 = 
k!(n−k)!
n!
​	
  ("Цэ из эн по ка") задаёт количество всевозможных сочетаний. Похожий вид имеет и количество сочетаний с повторениями (мультикомбинаций).

Запрограммируйте оба этих значения в виде функции, зависящей от n и k. Аргумент with_repetitions будет отвечать за вариант подсчёта: если он FALSE, то пусть считается количество сочетаний, а если TRUE, то сочетаний с повторениями.

Подсказки:

если вам необходима вспомогательная функция, её также можно определить. Назовите её как угодно.
в имеющейся декларации функции combin_count указано with_repetitions = FALSE. Это аргумент по умолчанию: оно будет подставлено, если вызвать функцию без указания with_repetitions, т.е. combin_count(10, 5) в точности эквивалентно combin_count(10, 5, FALSE).
подсчёт факториалов "в лоб" сопряжён с опасностью переполнения целочисленного типа. В данном случае я не буду проверять корректную работу при больших значениях n, оставим этот аспект за скобками.
если вы не знаете, как считать число сочетаний с повторениями, обратитесь к Википедии.

Решение :

    combin_count <- function(n, k, with_repretitions = FALSE) {
        if (with_repretitions) {
            factorial(n+k-1) / (factorial(k) * factorial(n-1))
        } else {
            factorial(n) / (factorial(k) * factorial(n-k))
        }
    }
