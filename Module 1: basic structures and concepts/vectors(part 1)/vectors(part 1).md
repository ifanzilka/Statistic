## [Back](https://github.com/ifanzilka/Statistic_for_R/blob/main/Module%201:%20basic%20structures%20and%20concepts/readme.md)
Векторы в R индексируются с 1, а не с 0!!!

###  Создание вектора :
  
    x <- vector(length = 2)
    x[1] <- 5
    x[2] <- 8
    x
Результат :    
  
    [1] 5 8

#### Но обычно используют более компактную запись :

    x <- c(5,8,2)
    x
Результат :    

    [1] 5 8 2

#### Функция "c" может быть и вложенной и принимать переменные :
    
     y <- c(x, 1 , c(3,4), x, NA)
     y
 Результат:

    [1]  5  8  2  1  3  4  5  8  2 NA

#### Создание векторов с шагом:

    5:9
Результат :
    
    [1] 5 6 7 8 9
Или 

    3:-1
    
Результат:

    [1]  3  2  1  0 -1

#### Более сложные последовательности :

  Функция  seq(от скольки, до скольки , шаг)
  
   Пример :
   
      seq(1, 2, by = 0.25)
Результат :      
      
      [1] 1.00 1.25 1.50 1.75 2.00
 #### Также в качестве параметра можно задать диапозон + кол-во элементов

Пример :
 
    seq(3, 4, length.out = 5)
Результат:

    [1] 3.00 3.25 3.50 3.75 4.00
      
#### Повтор векторов :
  Конструкция rep(вектор который хотим повторить, параметры)
   Пример :
   
      rep(1:3, times = 3)
Результат:

    [1] 1 2 3 1 2 3 1 2 3
Пример 2 (каждый элемент повторить):
   
      rep(1:3, each = 3)
Результат:

    [1] 1 1 1 2 2 2 3 3 3

Пример 3 (С фиксированным размером):
   
      rep(1:3, length.out = 5)
Результат:

    [1] 1 2 3 1 2
## Небольшой скрипт:
    hello <- "Hello, world!"
    print(hello)
    hello
    # comments
    c(1,3,2)
    c(3,2,1)
    0.1 + 0.1 == 0.2
    0.1 + 0.05 == 0.15
    # for double 
    all.equal(0.1 + 0.05, 0.15)
    ###
    u <- seq(0, 1, 1/3)
    v <- seq(0, 1, 1/7)
    c(u, v)

    ## Упорядочим

    w <- sort(c(u, v))

    ## Удаляем повторы 
    unique(w)
    
  ## Задача:
Вместе мы решили задачу про 1/3 и 1/7. Напишите функцию get_fractions, которая принимает на вход два числа, m и n, и возвращает аналогичный вектор, содержащий все дроби вида {i/m, i = 0, 1, ..., m} и  {j/n, j = 0, 1, ..., n}. Вектор не должен содержать повторов. И -- сюжетный поворот -- должен быть упорядочен в порядке убывания.

Решение :

    get_fractions <- function(m, n) 
    {
      u <- seq(0, 1, 1 / n)
      v <- seq(0, 1, 1 / m)
      w <-sort(c(u,v), decreasing = TRUE)
      w <-unique(w)
      return (w)
    }

# Типы векторов :
Bектора атомарные(все элементы одного типа)

Основные типы :

1.logical(TRUE/FALSE)

2.integer

3.numeric / double

4.complex

5.character(строки)

6.raw(байтовые последовательности)

Для определения типа вектора есть функции ***typeof*** и ***'is.* '*** (где * обозначает любой из типов)

**Пример** 1:

    a <- c("Дуб - дерево", "Роза - цветок", "Воробей - птица")
    typeof(a)
    
Результат:
    
    [1] "character"
    
**Пример** 2:

    is.character(a)
    
Результат:
    
    [1] TRUE

**Пример** 3:

    is.logical(a)
    
Результат:
    
    [1] FALSE

## Приведение типов

Естественным считается приведение слева направо по цепочке
logical — integer — double — character

**Пример** 1:

    b <- c(FALSE, 1.5)
    typeof(b)
    
То есть False привелся к 0 типа double    
Результат:
    
    [1] "double"
**Пример** 2:

    b <- c(5, b, "abc")
    typeof(b)
      
Результат:
    
    [1] "character"
**Вывод** 2:

    b
       
Результат:
    
    [1] "5"   "0"   "1.5" "abc"
## Принудительное приведение типов осуществляется функциями as.*:
**Пример** 1:
b - тип character попытаемся првиести к численным

    #as.double(b)
    as.numeric(b)
      
Результат:
    
    Warning: NAs introduced by coercion
    [1] 5.0 0.0 1.5  NA
