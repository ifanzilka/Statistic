## [Back](https://github.com/ifanzilka/Statistic_for_R/blob/main/Module%201:%20basic%20structures%20and%20concepts/readme.md)
Векторы в R индексируются с 1, а не с 0!!!
# Оглавление
* [Создание вектора ](#создание-вектора-)
* [Небольшой скрипт](#небольшой-скрипт)
* [Задача](#задача)
* [Типы векторов](#типы-векторов-)
* [Приведение типов](#приведение-типов)
* [Принудительное приведение типов осуществляется функциями as. * :](#принудительное-приведение-типов-осуществляется-функциями-as)
* [Длина вектора: length](#длина-вектора-length)
* [Именованные вектора](#именованные-вектора)
* [Векторная арифметика](#векторная-арифметика)
* [Векторизация](#векторизация)
* [Правила переписывания (recycling)](#правила-переписывания-recycling)
* [Доступ к элементам вектора (индексы)](#доступ-к-элементам-вектора-индексы)
* [Функции all и any](#функции-all-и-any)
* [Функция which](#функция-which)


###  Создание вектора :
  
    x <- vector(length = 2)
    x[1] <- 5
    x[2] <- 8
    x
Результат :    
  
    [1] 5 8

#### Но обычно используют более компактную запись :

    x <- c(5,8,2)
    x
Результат :    

    [1] 5 8 2

#### Функция "c" может быть и вложенной и принимать переменные :
    
     y <- c(x, 1 , c(3,4), x, NA)
     y
 Результат:

    [1]  5  8  2  1  3  4  5  8  2 NA

#### Создание векторов с шагом:

    5:9
Результат :
    
    [1] 5 6 7 8 9
Или 

    3:-1
    
Результат:

    [1]  3  2  1  0 -1

#### Более сложные последовательности :

  Функция  seq(от скольки, до скольки , шаг)
  
   Пример :
   
      seq(1, 2, by = 0.25)
Результат :      
      
      [1] 1.00 1.25 1.50 1.75 2.00
 #### Также в качестве параметра можно задать диапозон + кол-во элементов

Пример :
 
    seq(3, 4, length.out = 5)
Результат:

    [1] 3.00 3.25 3.50 3.75 4.00
      
#### Повтор векторов :
  Конструкция rep(вектор который хотим повторить, параметры)
   Пример :
   
      rep(1:3, times = 3)
Результат:

    [1] 1 2 3 1 2 3 1 2 3
Пример 2 (каждый элемент повторить):
   
      rep(1:3, each = 3)
Результат:

    [1] 1 1 1 2 2 2 3 3 3

Пример 3 (С фиксированным размером):
   
      rep(1:3, length.out = 5)
Результат:

    [1] 1 2 3 1 2
## Небольшой скрипт:
    hello <- "Hello, world!"
    print(hello)
    hello
    # comments
    c(1,3,2)
    c(3,2,1)
    0.1 + 0.1 == 0.2
    0.1 + 0.05 == 0.15
    # for double 
    all.equal(0.1 + 0.05, 0.15)
    ###
    u <- seq(0, 1, 1/3)
    v <- seq(0, 1, 1/7)
    c(u, v)

    ## Упорядочим

    w <- sort(c(u, v))

    ## Удаляем повторы 
    unique(w)
    
  ## Задача:
Вместе мы решили задачу про 1/3 и 1/7. Напишите функцию get_fractions, которая принимает на вход два числа, m и n, и возвращает аналогичный вектор, содержащий все дроби вида {i/m, i = 0, 1, ..., m} и  {j/n, j = 0, 1, ..., n}. Вектор не должен содержать повторов. И -- сюжетный поворот -- должен быть упорядочен в порядке убывания.

Решение :

    get_fractions <- function(m, n) 
    {
      u <- seq(0, 1, 1 / n)
      v <- seq(0, 1, 1 / m)
      w <-sort(c(u,v), decreasing = TRUE)
      w <-unique(w)
      return (w)
    }

# Типы векторов :
Bектора атомарные(все элементы одного типа)

Основные типы :

1.logical(TRUE/FALSE)

2.integer

3.numeric / double

4.complex

5.character(строки)

6.raw(байтовые последовательности)

Для определения типа вектора есть функции ***typeof*** и ***'is.* '*** (где * обозначает любой из типов)

**Пример** 1:

    a <- c("Дуб - дерево", "Роза - цветок", "Воробей - птица")
    typeof(a)
    
Результат:
    
    [1] "character"
    
**Пример** 2:

    is.character(a)
    
Результат:
    
    [1] TRUE

**Пример** 3:

    is.logical(a)
    
Результат:
    
    [1] FALSE

## Приведение типов

Естественным считается приведение слева направо по цепочке
logical — integer — double — character

**Пример** 1:

    b <- c(FALSE, 1.5)
    typeof(b)
    
То есть False привелся к 0 типа double    
Результат:
    
    [1] "double"
**Пример** 2:

    b <- c(5, b, "abc")
    typeof(b)
      
Результат:
    
    [1] "character"
**Вывод** 2:

    b
       
Результат:
    
    [1] "5"   "0"   "1.5" "abc"
## Принудительное приведение типов осуществляется функциями as.*:
**Пример** 1:
b - тип character попытаемся првиести к численным

    #as.double(b)
    as.numeric(b)
      
Результат:
    
    Warning: NAs introduced by coercion
    [1] 5.0 0.0 1.5  NA

**Пример** 2:
b - тип character попытаемся првиести к численным

    as.integer(b)
      
Результат:
    
    Warning: NAs introduced by coercion
    [1]  5  0  1 NA

## Длина вектора: length
Помимо типа, у любого вектора есть длина:

**Пример** 1:

    x <- 1:100
    length(x)
      
Результат:
    
    [1] 100
    
Длина определяется автоматически, но её можно принудительно менять:
**Пример** 2:
Длина вектора X была 4

    length(x) <- 7; 
    x
      
Результат :
    
    [1]  1  2  3  4 NA NA NA
    
## Именованные вектора
Элементы вектора могут быть проименованы:
**Пример** 1:

    a <- c(uno = 1, dos = 2, "universal answer" = 42, 99)
    names(a)
      
Результат:
    
    [1] "uno"              "dos"              "universal answer" ""
Или так :

**Пример** 2:

    names(a) <- c("one", "two", "forty two", "ninety nine")
    a
      
Результат:
    
    one         two   forty two ninety nine 
     1           2          42          99

Избавляемся от веткора имен :
      
      names(a) <- NUL

## Векторная арифметика

Арифметические операторы векторизованы (применяются поэлементно):
**Пример** 1:
Складываем вектора поэлементно

    1:3 + c(-1, 2, 0)
      
Результат:
    
    [1] 0 4 3
**Пример** 2:
Умножение поэлементно

    1:3 * c(-1, 2, 0)
      
Результат:
    
    [1] -1  4  0
**Пример** 3:
 Логический оператор '&' (И)

    c(TRUE, TRUE, TRUE) & c(0, 1, 999)
      
Результат:
    
    [1] FALSE  TRUE  TRUE

## Векторизация

Многие функции в R имеют встроенную поддержку векторизации:

**Пример** 1:

    # vectorized
    sqrt(1:4)
      
Результат:
    
    [1] 1.000000 1.414214 1.732051 2.000000
**Пример** 2:

    # vectorized
    floor(seq(0, 3, by = 0.25))
      
Результат:
    
    [1] 0 0 0 0 1 1 1 1 2 2 2 2 3
**Пример** 3:
    
    # not vectorized
    sum(1:100)
      
Результат:
    
    [1] 5050


## Правила переписывания (recycling)
Как работает арифметика на векторах разной длины?

Длина результата равна длине большего из векторов

Меньший вектор дублируется (переписывается) несколько раз, чтобы длина переписанного вектора совпала с длиной большего

Если длина большего вектора не делится нацело на длину меньшего, выдаётся предупреждение



    1:5 + 0:1
    # recycling in action: (1, 2, 3, 4, 5) + (0, 1, 0, 1, 0) => (1, 3, 3, 5, 5)
    
    ## Warning in 1:5 + 0:1: longer object length is not a multiple of shorter object length
    ## [1] 1 3 3 5 5

**Пример** 1:

    1:10 + 3
      
Результат:
    
    [1]  4  5  6  7  8  9 10 11 12 13
**Пример** 2:

    (5:8) ^ 2
      
Результат:
    
    [1] 25 36 49 64
**Пример** 3:
    
    1:4 >= 3
      
Результат:
    
    [1] FALSE FALSE  TRUE  TRUE

## Доступ к элементам вектора (индексы)
Рассмотрим простой вектор:

    x <- seq(10, 100, by = 10)
    
Чтение и запись элементов осуществляется при помощи оператора [:

    x[ind]
    val <- x[ind]
    x[ind] <- val
    
 Для аргумента ind есть несколько правил. Тривиальный случай   
 
    x[]
    [1]  10  20  30  40  50  60  70  80  90 100
    



## Положительные индексы

“Элементы с порядковыми номерами”:

    x[1]

    ## [1] 10

#
    x[3:4]

    ## [1] 30 40
#

    x[c(8, 7, 3, 6:8, x[1])]

    ## [1]  80  70  30  60  70  80 100


## Отрицательные индексы

“Все элементы, кроме указанных”:

    x[-5]

    ## [1]  10  20  30  40  60  70  80  90 100
#

    x[-(2:6)]

    ## [1]  10  70  80  90 100
#
    x[c(-3, -5, -length(x), -5)]

    ## [1] 10 20 40 60 70 80 90


## Логические индексы

“Элементы, соответствующие значению TRUE”:

    x[rep(c(TRUE, FALSE), 5)]

    ## [1] 10 30 50 70 90
#
    x[c(TRUE, FALSE)]

    ## [1] 10 30 50 70 90
#
    x[x > 77 & x < 99]

    ## [1] 80 90




## Индексация по имени

Для именованных векторов работает конструкция вида

    a[c("two", "one", "forty two")]

    ##       two       one forty two 
    ##         2         1        42
#
    a[c("forty two", "forty three", "forty four")]

    ## forty two      <NA>      <NA> 
    ##        42        NA        NA
#
## Функции all и any

    all(x < 200); all(x > 20)

    ## [1] TRUE

    ## [1] FALSE
#
    any(x > 150); any(x < 15)

    ## [1] FALSE

    ## [1] TRUE

# Функция which

    which(x >= 50)

    ## [1]  5  6  7  8  9 10
#
    which.min(x)

    ## [1] 1
#
    which.max(x)

    ## [1] 10

## Задача 
  Предположим, что у нас есть целочисленный вектор v и число n. Наша задача — найти позицию элемента в векторе, который ближе всего к числу n. При этом если таких элементов несколько, необходимо указать все позиции.

Напишите функцию, которая принимает на вход вектор и число и возвращает вектор индексов, отвечающих указанному условию. Индексы должны быть выстроены по возрастанию.

Пример. Пусть v <- c(5, 2, 7, 7, 7, 2, 0, 0) и n=1. Ответом будет вектор

2 6 7 8

Подсказки: 

"ближе всего" означает минимальную разницу между числами;
не забудьте про модуль!
  
    find_closest <- function(v, n) {
      x <- abs(v - n)
      which(x == min(x))
    }
