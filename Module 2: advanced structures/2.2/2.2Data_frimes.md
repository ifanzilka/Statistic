# [Back](https://github.com/ifanzilka/Statistic_for_R/blob/main/Module%202:%20advanced%20structures/module2.md)


## Дата фреймы
Дата фрейм (data frame) – двумерная таблица с данными (Excel spreadsheet, SQL-таблица)

Де-факто стандартный способ хранения данных в формате “наблюдения/переменные”:

строки соответствуют наблюдениям, столбцы – переменным

Places 	N_coord 	E_coord 	Date 	Temp

MM Faculty 	59.88 	29.83 	07.01.2014 	-15

PP Fortress 	59.95 	30.32 	15.05.2013 	17

SPbU main 	59.94 	30.3 	22.06.2013 	22

MM Faculty 	59.88 	29.83 	09.01.2014 	-21
… 	… 	… 	… 	…

data frame наследует свойства матрицы (прямоугольная форма) и списка (переменные могут быть разных типов)


## Создание дата фреймов
Перечисляем в параметрах (ключ - значение )

    df <- data.frame(x = 1:4, y = LETTERS[1:4], z = c(T, F))
    df
#
    ##   x y     z
    ## 1 1 A  TRUE
    ## 2 2 B FALSE
    ## 3 3 C  TRUE
    ## 4 4 D FALSE

Функция str – сводка об объекте:
#
str - От слова structers

    str(df)
#

    ## 'data.frame':    4 obs. of  3 variables:
    ##  $ x: int  1 2 3 4
    ##  $ y: Factor w/ 4 levels "A","B","C","D": 1 2 3 4
    ##  $ z: logi  TRUE FALSE TRUE FALSE


## Имена

    df <- data.frame(x = 1:4, y = LETTERS[1:4], z = c(T, F), 
                     row.names = c("Alpha", "Bravo", "Charlie", "Delta"))
    df
#
    ##         x y     z
    ## Alpha   1 A  TRUE
    ## Bravo   2 B FALSE
    ## Charlie 3 C  TRUE
    ## Delta   4 D FALSE
#
Вывод имен
        
        rownames(df);
        colnames(df) 
        #dimnames(df)
#
        ## [1] "Alpha"   "Bravo"   "Charlie" "Delta"
        ## [1] "x" "y" "z"



## Размерности

    nrow(df); 
    ncol(df) 
    #dim(df)
#
    ## [1] 4
    ## [1] 3

Две важные особенности:

 ‌ length(df) возвращает количество столбцов (переменных), а не общее количество элементов

‌ names(df) также возвращает имена столбцов

        length(df);
        names(df)
#

    ## [1] 3
    ## [1] "x" "y" "z"



## Индексация data frame

Как для матрицы:

    df[3:4, -1]
 #
        ##         y     z
        ## Charlie C  TRUE
        ## Delta   D FALSE
#
#
        df[c(F, T), c("z", "x")]
#

        ##           z x
        ## Bravo FALSE 2
        ## Delta FALSE 4



# Индексация data frame

        df[, 1]; 
        df[, 1, drop = FALSE]
#

        ## [1] 1 2 3 4
        ##         x
        ## Alpha   1
        ## Bravo   2
        ## Charlie 3
        ## Delta   4

Как для списка:

    df$z #df[[3]]; 
    df[["z"]]
#
    ## [1]  TRUE FALSE  TRUE FALSE


## Фильтрация по условию
Переменная (x) > 2

    df[df$x > 2, ]
#

        ##         x y     z
        ## Charlie 3 C  TRUE
        ## Delta   4 D FALSE

#
#
Тоже самое , только немного по другому

    subset(df, x > 2)
#

    ##         x y     z
    ## Charlie 3 C  TRUE
    ## Delta   4 D FALSE

#
#
Также при помощи select указыает условие для строк

    subset(df, x > 2, select = c(x, z))
#
        ##         x     z
        ## Charlie 3  TRUE
        ## Delta   4 FALSE



## Комбинирование data frame

Функции rbind/cbind работают как для матриц:
Присоединяем к dataframe df созданный dataframe


        rbind(df, data.frame(x = 5:6, y = c("K", "Z"), z = TRUE, row.names = c("Kappa", "Zulu")))

#
    ##         x y     z
    ## Alpha   1 A  TRUE
    ## Bravo   2 B FALSE
    ## Charlie 3 C  TRUE
    ## Delta   4 D FALSE
    ## Kappa   5 K  TRUE
    ## Zulu    6 Z  TRUE
#
#
Присоединяем столбцы

    cbind(df, data.frame(season = c("Summer", "Autumn", "Winter", "Spring"), temp = c(20, 5, -10, 5)))

#
        ##         x y     z season temp
        ## Alpha   1 A  TRUE Summer   20
        ## Bravo   2 B FALSE Autumn    5
        ## Charlie 3 C  TRUE Winter  -10
        ## Delta   4 D FALSE Spring    5



## Комбинирование data frame: merge

    df
#

        ##         x y     z
        ## Alpha   1 A  TRUE
        ## Bravo   2 B FALSE
        ## Charlie 3 C  TRUE
        ## Delta   4 D FALSE
#
#
        df_salary <- data.frame(x = c(3, 2, 6, 1), salary = c(100, 1000, 300, 500))
        merge(df, df_salary, by = "x")
#

        ##   x y     z salary
        ## 1 1 A  TRUE    500
        ## 2 2 B FALSE   1000
        ## 3 3 C  TRUE    100

Для тех, кто знаком с SQL: это inner join.

Остальные типы (left, right, outer, cross join) легко найти на stackoverflow по запросу “r joins”.

## Задача 

Анализ данных -- это далеко не всегда заумные академические модели в вакууме. Иногда на основе простых манипуляций можно сделать разумные выводы и облегчить принятие повседневных решений.

Дата фрейм attitude -- встроенный массив данных, содержащий рейтинг департаментов одной финансовой компании, составленный сотрудниками. Представьте, что вы хотите устраиваться как раз в эту компанию, и дата фрейм (совершенно случайно!) оказался в вашем распоряжении. 

Вы решили, что самое главное для вас -- это возможность учиться новому (learning). Возьмите 5 топовых департаментов по этому показателю. Из этого набора вам более всего подойдёт тот департамент, который имеет наибольшую сумму баллов по трём показателям: реакция на жалобы работников (complaints), надбавки в зависимости от результатов работы (raises) и возможность продвижения (advance).

Какой же департамент вам выбрать? Напишите его номер XX (номер строки в дата фрейме).

Решение :
    1.Встроенный массив в a
        
        a <- attitude
    
   2.сортируем (- по убыванию) по столбцы learning и выбираем первые 5 строк
        
        b <-a[head(order(-a $learning),5),]
   3.Суммирую все компоненты и записываю в столбец sm     
   
        b$sm<-b$complaints+b$raises+b$advance
        
   4.#сортируем и смотрим имя строки для первого
        
        rownames(b[head(order(-b$sm),1),])

## Импорт данных


## Чтение табличных данных
Основной инструмент : 
#### read.table
 file  - имя файла
 
 header -  Наличие заголовка
 
 sep - разделитель значений
 
 quote - символы, обозначающие кавычки (для строкового типа)
 
 na.strings - строки , кодирующие пропущенные значения
 
 colClasses - типы столбцов (для быстродествия указания типа)
 
 comment.char - символ обозначающий коментарий 
 
 skip  -  кол - во строк пропускаемых с начала
 
 Или посмотреть справку  read.table
 
 
 ## Предобработка данных
 
 1.Импорт в дата фрейм
 
 2.Очистка значений, проверка типов
 
 3.Работа со строками, имена , переменный строкового типа, факторы
 
 4.Пропущенные значения, идентефикация , способ обработки
 
 5. Манипулирование переменными , преобразование , создание удаление

 6. Подсчет описательных статистик. split-apply-combit
 
 7. Визуализация данных.
 
 8. Экспорт очищенных данных
 
 ## Очистка значенией, проверка типов
 Типы переменных на которых легко ошибиться при импорте :
 
 ### 1.Числовые типы становятся строковыми
 1. Из пропущенных значений , отмечены не как NA
 
        na.strings = c("NA","Not Avaliable", "Missing")
 2.Из за неверно указанного разделителя, десятичного знака 
        
        sep = "," ,dec = "."
  3.Из за ковычек, сопроводительного текста или коментариев
  
        quote, comment.char, skip
  ### 2.Строковые типы становятся факторами, или наоборот
    
        as.character, as.factor      
  ### 3.Тип "дата/время " становится строковым
 
 
Функции str, summary, head , tail помогают проверить все ли в порядке
 
 
 ## Работа с переменными
 
  1.Функция  `complete.cases`  и `na.omit`  для удаления наблюдений с пропущенными значениями
        
        df[complete.cases(df)]
        na.omit(df)
  2.Замена NA на некоторые значения  может быть опасной
  
  3.Создание, изменение и удаление перменных выполняется :
        
        df$new_var <- <...>
        df$old_var <-f(df$old_var)
        df$old_var <- NULL
        
   4. Кроме того для большого кол - ва переменных есть функция `within`    
    
    
  ## Экспорт 
  
  `write.table`, `write.csv `,  `write.csv2 ` практически идентичны функциям импорта 
  
  Если у вас большой массив данных , лучше всего отделять этап предобработки данных
