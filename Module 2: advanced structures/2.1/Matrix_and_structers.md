# [Back](https://github.com/ifanzilka/Statistic_for_R/blob/main/Module%202:%20advanced%20structures/module2.md)

# Оглавление
* [Матрица](#матрица)
* [Создание матриц](#создание-матриц)
* [Атрибут dim](#атрибут-dim)
* [Арифметические операторы](#арифметические-операторы)
* [Арифметические операторы2](#арифметические-операторы2)
* [Индексирование матриц](#индексирование-матриц)
* [Схлопывание размерности](#схлопывание-размерности)
* [Именованные матрицы: rownames/colnames](#именованные-матрицы-rownamescolnames)
* [Присоединение матриц: rbind/cbind](#присоединение-матриц-rbindcbind)
* [Аргумент ... (ellipsis)](#аргумент--ellipsis)
* [Применение функций к матрице: apply](#применение-функций-к-матрице-apply)
* [Применение функций к матрице: apply](#применение-функций-к-матрице-apply-1)
* [Наиболее частые операции по строкам и столбцам – sum и mean:](#наиболее-частые-операции-по-строкам-и-столбцам--sum-и-mean)
* [Задача](#задача)
* [Соединяем матрицы](#соединяем-матрицы)
* [Список](#список)
* [Создание списков](#создание-списков)
* [Конкатенация списков](#конкатенация-списков)
* [Конверсия между списком и вектором](#конверсия-между-списком-и-вектором)
* [Доступ к элементам списка](#доступ-к-элементам-списка)
* [Замена и добавление элементов списка](#замена-и-добавление-элементов-списка)
* [Применение функций к списку: lapply](#применение-функций-к-списку-lapply)
* [Применение функций к списку: lapply, sapply](#применение-функций-к-списку-lapply-sapply)
* [Частичное дополнение по $ и аргументам функции](#частичное-дополнение-по--и-аргументам-функции)
* [Задачи](#задачи)
* [generate list with random length and contents](#generate-list-with-random-length-and-contents)
* [Задача](#задача-1)
* [Задача 2](#задача-2)
  ## Матрица
Матрица – двумерный массив данных одного типа

По сути, это вектор, уложенный по столбцам (!)

Для создания матрицы можно использовать функцию matrix

    matrix(1:6, nrow = 2, ncol = 3)
 #
    ##      [,1] [,2] [,3]
    ## [1,]    1    3    5
    ## [2,]    2    4    6


## Создание матриц

Избавимся от ненужной избыточности:

    matrix(1:6, nrow = 2)
#
    ##      [,1] [,2] [,3]  
    ## [1,]    1    3    5
    ## [2,]    2    4    6
Упокуем по строчкам

    matrix(1:6, nrow = 2, byrow = TRUE)
#
    ##      [,1] [,2] [,3]
    ## [1,]    1    2    3
    ## [2,]    4    5    6

Или так

    matrix(7:8, nrow = 2, ncol = 5)
#

    ##      [,1] [,2] [,3] [,4] [,5]
    ## [1,]    7    7    7    7    7
    ## [2,]    8    8    8    8    8


## Атрибут dim

    m <- matrix(1:6, ncol = 3)
    dim(m)
#
    ## [1] 2 3
Или так посмотреть размеры

    c(nrow(m), ncol(m))
#
    ## [1] 2 3

Превращаем в вектор:

    dim(m) <- NULL; m 
#
    ## [1] 1 2 3 4 5 6

Или так :
    
    dim(m) <- c(2, 3); m
#

    ##      [,1] [,2] [,3]
    ## [1,]    1    3    5
    ## [2,]    2    4    6


## Арифметические операторы

Действуют поэлементно, с учётом правил преписывания:

    m1 <- matrix(1:4, nrow = 2) 
    m2 <- matrix(c(1, 2, 2, 3), nrow = 2)
    m1 + m2
#
    ##      [,1] [,2]
    ## [1,]    2    5
    ## [2,]    4    7
Еще :
  
    m1 + 5
#
    ##      [,1] [,2]
    ## [1,]    6    8
    ## [2,]    7    9



## Арифметические операторы2
Умножение на число

    m1 * 2
#
    ##      [,1] [,2]
    ## [1,]    2    6
    ## [2,]    4    8

Умножение поэлементно
  
    m1 * m2
#
    ##      [,1] [,2]
    ## [1,]    1    6
    ## [2,]    4   12

Умножение в смысле линейной алгебры:

    m1 %*% m2
#
    ##      [,1] [,2]
    ## [1,]    7   11
    ## [2,]   10   16
#

    |a1    b1|        |c1    d1|          |a1c1 + b1c2    a1d1 + b1d2|
    |        |   *    |        |    =     |                          |
    |a2    b2|        |c2    d2|          |a2c1 + b2c2    a2d1 + b2d2|

## Индексирование матриц

Те же правила, что и для векторов, но с учётом двух размерностей:

    m <- matrix(1:10, ncol = 5)
    m[1, 3]
#
    ## [1] 5

Или так
    
    m[2, ]
#
    ## [1]  2  4  6  8 10
or

    m[, 4]
#
    ## [1] 7 8

Замена элемента

    m[1, ] <- 0;
    m
#
    ##      [,1] [,2] [,3] [,4] [,5]
    ## [1,]    0    0    0    0    0
    ## [2,]    2    4    6    8   10
OR

    m[, -5] <- 11:18; 
    m
#

    ##      [,1] [,2] [,3] [,4] [,5]
    ## [1,]   11   13   15   17    0
    ## [2,]   12   14   16   18   10



## Схлопывание размерности

    m <- matrix(1:10, ncol = 5)
    ind <- c(1, 3, 5)
    m[, ind]
#

    ##      [,1] [,2] [,3]
    ## [1,]    1    5    9
    ## [2,]    2    6   10
OR

    ind <- 3
    m[, ind]
#
    ## [1] 5 6

OR

drop для получение подматрциы а не вектора
    
    m[, ind, drop = FALSE]
#
    ##      [,1]
    ## [1,]    5
    ## [2,]    6

У TRUE и FALSE есть однобуквенные сокращения (T и F): drop = F


## Именованные матрицы: rownames/colnames

    m <- matrix(1:10, ncol = 5)
    rownames(m) <- c("row1", "row2")
    colnames(m) <- paste0("column", 1:5)
    m
paset0 склеивает аргументы    
#


    ##      column1 column2 column3 column4 column5
    ## row1       1       3       5       7       9
    ## row2       2       4       6       8      10
OR

    m["row1", c("column2", "column4"), drop = F]
#
    ##      column2 column4
    ## row1       3       7


## Присоединение матриц: rbind/cbind

    rbind(m1, m2)
# 
Присоединение по столбцам

    ##      [,1] [,2]
    ## [1,]    1    3
    ## [2,]    2    4
    ## [3,]    1    2
    ## [4,]    2    3

    cbind(m1, m2)
#
По строкам

    ##      [,1] [,2] [,3] [,4]
    ## [1,]    1    3    1    2
    ## [2,]    2    4    2    3



## Аргумент ... (ellipsis)

Новый аспект R: аргумент ... позволяет передавать любое количество объектов


    cbind(m1, m2, 1:2, c(5, 3), m2[, 1], m1 * 3, cbind(m2, m1))
#
    ##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
    ## [1,]    1    3    1    2    1    5    1    3    9     1     2     1     3
    ## [2,]    2    4    2    3    2    3    2    6   12     2     3     2     4

Другие примеры: c, paste, paste0, sum.

## Применение функций к матрице: apply
Применение функций к строчкам и столбцам

    m <- matrix(1:25, 5)
    f <- function(x) sum(x^2)

Три аргумента функции apply:

Массив (матрица)

Индекс (1 – по строкам, 2 – по столбцам)

Функция

Пример По строкам :

    apply(m, 1, f)
#
    ## [1]  855  970 1095 1230 1375
OR ПО столбцам

    apply(m, 2, f)
#
    ## [1]   55  330  855 1630 2655

## Применение функций к матрице: apply

    
    apply(m, 1:2, function(i) if (i>13) i else 13)
#

    ##      [,1] [,2] [,3] [,4] [,5]
    ## [1,]   13   13   13   16   21
    ## [2,]   13   13   13   17   22
    ## [3,]   13   13   13   18   23
    ## [4,]   13   13   14   19   24
    ## [5,]   13   13   15   20   25

или что тоже самое :

    m[m <= 13] <- 13; m
#

    ##      [,1] [,2] [,3] [,4] [,5]
    ## [1,]   13   13   13   16   21
    ## [2,]   13   13   13   17   22
    ## [3,]   13   13   13   18   23
    ## [4,]   13   13   14   19   24
    ## [5,]   13   13   15   20   25

Такая функция (не имеющая имени) называется анонимной


## rowSums, rowMeans, colSums, colMeans
## Наиболее частые операции по строкам и столбцам – sum и mean:

    m <- matrix(1:25, 5)
    rowSums(m)
#
    ## [1] 55 60 65 70 75

Проверим, что это действительно так:

    all.equal(rowSums(m), apply(m, 1, sum))
#

    ## [1] TRUE

OR

    all.equal(colMeans(m), apply(m, 2, mean))
#
    ## [1] TRUE


## Задача 
  Предположим, что у нас есть целочисленный вектор v и число n. Наша задача — найти позицию элемента в векторе, который ближе всего к числу n. При этом если таких элементов несколько, необходимо указать все позиции.

Напишите функцию, которая принимает на вход вектор и число и возвращает вектор индексов, отвечающих указанному условию. Индексы должны быть выстроены по возрастанию.

Пример. Пусть v <- c(5, 2, 7, 7, 7, 2, 0, 0) и n=1. Ответом будет вектор

2 6 7 8

Подсказки: 

"ближе всего" означает минимальную разницу между числами;
не забудьте про модуль!
  
    find_closest <- function(v, n) {
      x <- abs(v - n)
      which(x == min(x))
    }
## Соединяем матрицы

    # bind matrices diagonally  
    bind_diag <- function(m1, m2, fill) {
      m3 <- matrix(fill, 
               nrow = nrow(m1) + nrow(m2), 
               ncol = ncol(m1) + ncol(m2))
      m3[1:nrow(m1), 1:ncol(m1)] <- m1
      m3[nrow(m1) + 1:nrow(m2), ncol(m1) + 1:ncol(m2)] <- m2
      m3  
    }
#
    m1 <- matrix(1:12, nrow = 3)
    m2 <- matrix(10:15, ncol = 3)
    bind_diag(m1, m2, fill = NA)
    bind_diag(m2, m1, fill = 0)


## Список

   Список – индексированная структура
   
   Элементами списка могут быть произвольные объекты
   
   Обычно используется для хранения данных различной длины или различных типов
   
   Создание списков осуществляется функцией list

    
    list(1:5, "my_data", matrix(0, 2, 2))
#

    ## [[1]]
    ## [1] 1 2 3 4 5
    ## 
    ## [[2]]
    ## [1] "my_data"
    ## 
    ## [[3]]
    ##      [,1] [,2]
    ## [1,]    0    0
    ## [2,]    0    0


## Создание списков

    list(a = 1, b = 1:3, "1to5" = 1:5, 42)
#
    ## $a
    ## [1] 1
    ## 
    ## $b
    ## [1] 1 2 3
    ## 
    ## $`1to5`
    ## [1] 1 2 3 4 5
    ## 
    ## [[4]]
    ## [1] 42
#
Список может быть рекурсивным:

    list(a = list(1, 2, 3), b = list(list(4), 5, 6))



## Конкатенация списков

    l1 <- list(name = "john", salary = 1000)
    l2 <- list(has_car = TRUE, car = "lamborghini")
    c(l1, l2)
#
    ## $name
    ## [1] "john"
    ## 
    ## $salary
    ## [1] 1000
    ## 
    ## $has_car
    ## [1] TRUE
    ## 
    ## $car
    ## [1] "lamborghini"


## Конверсия между списком и вектором

Любой вектор легко свести к списку:

    v <- 1:7
    list(v)
#
    ## [[1]]
    ## [1] 1 2 3 4 5 6 7

Но не наоборот! Если сведение осмыслено, то есть unlist:

    l <- list(1:3, 4:5, last = 6)
    unlist(l)
#
    ##                          last 
    ##    1    2    3    4    5    6
#
  
    unlist(c(l, "spy!"))
#
    ##                                      last        
    ##    "1"    "2"    "3"    "4"    "5"    "6" "spy!"



## Доступ к элементам списка

Первый способ: как для векторов, []

    l[3:2]; l[-(1:2)]
#

    ## $last
    ## [1] 6
    ## 
    ## [[2]]
    ## [1] 4 5

    ## $last
    ## [1] 6
#
#
    l[c(F, T, F)]; l["last"]
#
    ## [[1]]
    ## [1] 4 5

    ## $last
    ## [1] 6
    
    
Второй способ: доступ к конкретному элементу, [[]]

    l[[1]]
#

    ## [1] 1 2 3
OR

    l[["last"]]
#
    ## [1] 6


Третий способ: доступ по имени с частичным дополнением, $

    l$last
#

    ## [1] 6

OR
    
     l$l #l$la; l$las
#

    ## [1] 6


Доступ к элементам списка

  Одинарные скобки
        
  действуют векторные правила индексирования
        
  
  возвращаемое значение – подсписок
  
  Двойные скобки
  
  (скалярный) номер элемента или его полное имя
  
  возвращаемое значение – элемент списка
  
  Знак доллара
  
  частичное имя элемента
  
  возвращаемое значение – элемент списка





## Замена и добавление элементов списка

    l <- list(1:3, 4:5, last = 6)
    l[[3]] <- NULL; 
    l
#

    ## [[1]]
    ## [1] 1 2 3
    ## 
    ## [[2]]
    ## [1] 4 5

OR
    
    l[[4]] <- 99; l
#
    ## [[1]]
    ## [1] 1 2 3
    ## 
    ## [[2]]
    ## [1] 4 5
    ## 
    ## [[3]]
    ## NULL
    ## 
    ## [[4]]
    ## [1] 99




Можно хранить так же функцию

    l <- list(vec = 1:7, fun = sqrt) #l$fun(4)
    names(l)
#
    ## [1] "vec" "fun"

А теперь  обнулим ключ string и потом добавим по этому ключу:

    is.null(l$string)
#
    ## [1] TRUE

    l$string <- "Citius, altius, fortius" 
    l

    ## $vec
    ## [1] 1 2 3 4 5 6 7
    ## 
    ## $fun
    ## function (x)  .Primitive("sqrt")
    ## 
    ## $string
    ## [1] "Citius, altius, fortius"




## Применение функций к списку: lapply

      l <- list(a = c("12", "34"), b = LETTERS[5:10], c = 1:5)
      lapply(l, length)
#

Применяем функцию length
    
    ## $a
    ## [1] 2
    ## 
    ## $b
    ## [1] 6
    ## 
    ## $c
    ## [1] 5


## Применение функций к списку: lapply, sapply

    lapply(l, paste, collapse = "|")
склеиваем

    ## $a
    ## [1] "12|34"
    ## 
    ## $b
    ## [1] "E|F|G|H|I|J"
    ## 
    ## $c
    ## [1] "1|2|3|4|5"
Или  так

    #lapply(l, function(s) paste(s, collapse = "|"))

Чтобы получился вектор

    sapply(l, paste, collapse = "|")
#
    ##             a             b             c 
    ##       "12|34" "E|F|G|H|I|J"   "1|2|3|4|5"



## Частичное дополнение по $ и аргументам функции

    l <- list(some_name = 1, incredibly_long_name = 2)
    l$incr + 1
#
    ## [1] 3
Сокраещеам запись функций

    f <- function(x, ridiculously_long_arg) x + ridiculously_long_arg
    f(3, ridic = 5) #f(3, 5)
 # 
    ## [1] 8

# Задачи
Возвращаем список, возвращаем позиции максимумов.
### get the longest element

    get_longest <- function(l) {
      len <- sapply(l, length)
      list(number = which.max(len), element = l[[which.max(len)]])
    }
 Или так
 
    get_longest <- function(l){
      len <- sapply(l, length)
      ind <- which(len == max(len))
      list(number = ind, element = l[ind])
    }
# generate list with random length and contents
    gen_list <- function(n_elements, max_len, seed = 111) {
      set.seed(seed)
      len <- sample(1:max_len, n_elements)
      lapply(1:n_elements, function(i) rnorm(len[i]))
    }
#

    l1 <- gen_list(4, 10)
    l1
    gl1 <- get_longest(l1)
    gl1$number
    l2 <- gen_list(4, 10, 777)
    l2
    get_longest(l2)


## Задача 

Если вектор достаточно длинный, то визуально сложно оценить, какие в нём содержатся элементы и сколько раз они повторяются. В этом случае полезно будет посмотреть на таблицу частот элементов.

Пусть x -- целочисленный вектор. Напишите функцию, которая вернёт матрицу из двух строк. В первой строке перечислите все различные элементы вектора, упорядоченные 
по возрастанию. Во второй строке укажите частоты (количество повторов) этих элементов.

Пример. Пусть x <- c(5, 2, 7, 7, 7, 2, 0, 0). Тогда функция должна вернуть матрицу 2х4 с элементами

0 2 5 7

2 2 1 3

Решение:

    count_elements <- function(x) {
      row1 <- unique(sort(x))
      row2 <- rep(0, length(row1))
      mat <- matrix(0,2,length(row1))
      for (i in 1:length(row1)) {
        mat[2,i] <- length(which(row1[i] == x))
      }
      for (i in 1:length(row1)) {
        mat[1,i] <- row1[i]
      }
      return(mat)
    }
 В row1 уникальные узначения отсортированны
 
 row2 Пустой список от 0 до len(row1)
 
 Потом создаем матрицу нулей размера 2 x qlen(row)
 
 Потом заполняю
 
## Задача 2

  Парижане бунтуют! По слухам, Бастилия плохо охраняется, а её арсеналы полны пороха и мушкетов.
Пришло время решительных действий. Наши агенты смогли подсчитать количество солдат в патрулях в каждой из восьми башен крепости. Вот эти данные:

    set.seed(1789)
    bastille <- list(
      "La Chapelle Tower" = rbinom(5, 10, 1/2), 
      "Tresor Tower" = rbinom(8, 12, 1/4), 
      "Comte Tower" = rbinom(14, 3, 1/5) + 1,
      "Baziniere Tower" = rbinom(8, 4, 4/5), 
      "Bertaudiere Tower" = rbinom(4, 8, 2/3),
      "Liberte Tower" = rbinom(1, 100, 0.1), 
      "Puits Tower" = rbinom(5, 5, 0.7),
      "Coin Tower" = rbinom(3, 16, 0.4)
    )
 
Составьте короткий отчёт: какая из башен менее всего защищена, сколько в ней солдат, и сколько всего солдат в Бастилии? Свобода, равенство, братство!
P.S. Формат ответа: tower_name, XX, YY﻿: полное название башни как в списке (без кавычек) и два числа. В качестве разделителя -- запятая и пробел.

Решение  :

    b <- sapply(bastille, sum)
    paste(c(names(which.min(b)), min(b), sum(b)), collapse = ", ")
