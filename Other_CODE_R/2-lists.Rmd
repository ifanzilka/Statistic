---
title: "Матрицы и списки"
author: "<i>Основы программирования на R</i><br><br>Антон Антонов"
output: 
  revealjs::revealjs_presentation:
    theme: serif
    highlight: tango
    center: false
    transition: fade
    pandoc_args: [ 
      "--slide-level", "1", 
      "--include-in-header", "custom.css"
    ]
---

```{r setup, echo=FALSE}
options(width = 110)
```

# Матрица

>- Матрица -- двумерный массив данных одного типа
>- По сути, это вектор, уложенный по столбцам (!)
>- Для создания матрицы можно использовать функцию `matrix`

. . . 

```{r}
matrix(1:6, nrow = 2, ncol = 3)
```

# Создание матриц

. . .

Избавимся от ненужной избыточности:

```{r}
matrix(1:6, nrow = 2)
```

. . .

```{r}
matrix(1:6, nrow = 2, byrow = TRUE)
```

. . .

```{r}
matrix(7:8, nrow = 2, ncol = 5)
```

# Атрибут `dim`

. . .

```{r}
m <- matrix(1:6, ncol = 3)
dim(m)
c(nrow(m), ncol(m))
```

. . .

```{r}
dim(m) <- NULL; m 
dim(m) <- c(2, 3); m
```

# Арифметические операторы

. . .

Действуют поэлементно, с учётом правил преписывания:

```{r}
m1 <- matrix(1:4, nrow = 2) 
m2 <- matrix(c(1, 2, 2, 3), nrow = 2)
```

. . .

```{r}
m1 + m2
m1 + 5
```

# Арифметические операторы

. . .

```{r}
m1 * 2
m1 * m2
```

. . .

Умножение в смысле линейной алгебры:
```{r}
m1 %*% m2
```

# Индексирование матриц

. . .

Те же правила, что и для векторов, но с учётом двух размерностей:

```{r}
m <- matrix(1:10, ncol = 5)
m[1, 3]
```

. . .

```{r}
m[2, ]
m[, 4]
```

# Индексирование матриц

. . .

```{r}
m[1, ] <- 0; m
```

. . .

```{r}
m[, -5] <- 11:18; m
```

# Схлопывание размерности

. . .

```{r}
m <- matrix(1:10, ncol = 5)
ind <- c(1, 3, 5)
m[, ind]
```

. . .

```{r}
ind <- 3
m[, ind]
```

. . .

```{r}
m[, ind, drop = FALSE]
```
У `TRUE` и `FALSE` есть однобуквенные сокращения (`T` и `F`): `drop = F`

# Именованные матрицы: `rownames`/`colnames`

. . .

```{r}
m <- matrix(1:10, ncol = 5)
rownames(m) <- c("row1", "row2")
colnames(m) <- paste0("column", 1:5)
```

. . .

```{r}
m
```

. . .

```{r}
m["row1", c("column2", "column4"), drop = F]
```

# Присоединение матриц: `rbind`/`cbind`

. . .

```{r}
rbind(m1, m2)
```

. . .

```{r}
cbind(m1, m2)
```

# Аргумент `...` (ellipsis)

. . .

Новый аспект R: аргумент `...` позволяет передавать любое количество объектов
```{r}
cbind(m1, m2, 1:2, c(5, 3), m2[, 1], m1 * 3, cbind(m2, m1))
```

. . .

Другие примеры: `c`, `paste`, `paste0`, `sum`.

# Применение функций к матрице: `apply`

. . .

```{r}
m <- matrix(1:25, 5)
f <- function(x) sum(x^2)
```

. . .

Три аргумента функции `apply`: 

>- Массив (матрица)
>- Индекс (1 -- по строкам, 2 -- по столбцам)
>- Функция

. . .
```{r}
apply(m, 1, f)
apply(m, 2, f)
```

# Применение функций к матрице: `apply`

. . .

```{r}
apply(m, 1:2, function(i) if (i>13) i else 13)
```

. . .

```{r}
m[m <= 13] <- 13; m
```

. . .

Такая функция (не имеющая имени) называется _анонимной_.

# `rowSums`, `rowMeans`, `colSums`, `colMeans`

. . .

Наиболее частые операции по строкам и столбцам -- `sum` и `mean`:
```{r}
m <- matrix(1:25, 5)
rowSums(m)
```

. . .

Проверим, что это действительно так:
```{r}
all.equal(rowSums(m), apply(m, 1, sum))
all.equal(colMeans(m), apply(m, 2, mean))
```

# Список

>- Список -- индексированная структура
>- Элементами списка могут быть произвольные объекты
>- Обычно используется для хранения данных различной длины или различных типов
>- Создание списков осуществляется функцией `list`

. . . 

```{r}
list(1:5, "my_data", matrix(0, 2, 2))
```

# Создание списков

. . . 

```{r}
list(a = 1, b = 1:3, "1to5" = 1:5, 42)
```

. . . 

Список может быть рекурсивным:

```{r, eval = FALSE}
list(a = list(1, 2, 3), b = list(list(4), 5, 6))
```

# Конкатенация списков

. . .

```{r}
l1 <- list(name = "john", salary = 1000)
l2 <- list(has_car = TRUE, car = "lamborghini")
```

. . . 

```{r}
c(l1, l2)
```

# Конверсия между списком и вектором

. . .

Любой вектор легко свести к списку:

```{r}
v <- 1:7
list(v)
```

. . .

Но не наоборот! Если сведение осмыслено, то есть `unlist`:

```{r}
l <- list(1:3, 4:5, last = 6)
unlist(l)
```

. . .

```{r}
unlist(c(l, "spy!"))
```

# Доступ к элементам списка 

. . .

Первый способ: как для векторов, `[]`

. . .

```{r}
l[3:2]; l[-(1:2)]
```

. . .

```{r}
l[c(F, T, F)]; l["last"]
```

# Доступ к элементам списка 

. . .

Второй способ: доступ к конкретному элементу, `[[]]`

. . .

```{r}
l[[1]]
l[["last"]]
```

# Доступ к элементам списка 

. . .

Третий способ: доступ по имени с частичным дополнением, `$`

. . .

```{r}
l$last
```

. . .

```{r}
l$l #l$la; l$las
```

# Доступ к элементам списка

>- Одинарные скобки
    + действуют векторные правила индексирования
    + возвращаемое значение -- подсписок
>- Двойные скобки
    + (скалярный) номер элемента или его полное имя
    + возвращаемое значение -- элемент списка
>- Знак доллара
    + частичное имя элемента
    + возвращаемое значение -- элемент списка
    
# Замена и добавление элементов списка

. . .

```{r}
l <- list(1:3, 4:5, last = 6)
l[[3]] <- NULL; l
```

. . .

```{r}
l[[4]] <- 99; l
```

# Замена и добавление элементов списка

. . .

```{r}
l <- list(vec = 1:7, fun = sqrt) #l$fun(4)
names(l)
is.null(l$string)
```

. . .

```{r}
l$string <- "Citius, altius, fortius"
l
```
    
    
# Применение функций к списку: `lapply` 

. . .

```{r}
l <- list(a = c("12", "34"), b = LETTERS[5:10], c = 1:5)
```

. . .

```{r}
lapply(l, length)
```

# Применение функций к списку: `lapply`, `sapply`

. . .

```{r}
lapply(l, paste, collapse = "|")
#lapply(l, function(s) paste(s, collapse = "|"))
```

. . .

```{r}
sapply(l, paste, collapse = "|")
```

# Частичное дополнение по $ и аргументам функции

```{r}
l <- list(some_name = 1, incredibly_long_name = 2)
l$incr + 1
```

. . .

```{r}
f <- function(x, ridiculously_long_arg) x + ridiculously_long_arg
f(3, ridic = 5) #f(3, 5)
```

# Глоссарий

. . .

`?matrix`

`?dim`, `?rownames`, `?colnames`

`?rbind`, `?cbind`, `?apply`

`?rowSums`, `?rowMeans`, `?colSums`, `?colMeans`

`?list`, `?unlist`

`?"["` (`?"[["`, `?"$"`)

`?lapply`, `?sapply`

Partial matching, `?"..."` (ellipsis)